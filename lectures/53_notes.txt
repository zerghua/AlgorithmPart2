Introduction to Substring Search
----------------------------------------------------------
Goal. Find pattern of length M in a text of length N.

substring search applications.
Screen scraping. Extract relevant data from web page.
Ex. Find string delimited by <b> and </b> after first
occurrence of pattern Last Trade.




Brute-Force Substring Search
----------------------------------------------------------
public static int search(String pat, String txt){
    int M = pat.length();
    int N = txt.length();
    for(int i=0; i<= N ; i++){
        int j;
        for(j = 0; j<M; j++){
            if(txt.charAt(i+j) != pat.charAt(j)) break;
        }
        if(j == M) return i;    // found
    }
    return N; // not found
}


can be slow if txt and pattern are repetitive.


Backup
In many applications, we want to avoid backup in next stream.
- Treat input as stream of data.
- Abstract model: standard input.

Brute force algorithm needs to backup for every mismatch.

Approach 1. Maintain buffer of last M characters.

best case is M, worse case is M*N

// alternating brute force code
public int search(String txt){
    int i, j, N = txt.length();
    for(i = 0, j =0; i< N && j < M; i++){
        if(txt.charAt(i) == pat.charAt(j)) j++;
        else{i -= j; j = 0 ;}
    }
    if(j == M) return i - M;
    else return N;
}


Knuth–Morris–Pratt
----------------------------------------------------------
KMP. clever method to always avoid backup.


Deterministic finite state automation(DFA)
DFA is abstract string-search machine.
- Finite number of states(including start and halt).
- Exactly one transition for each char in alphabet.
- Accept if sequence of transitions leads to halt state.


public int search(String txt){
    int i, j, N = txt.length();
    for(i = 0, j =0; i< N && j < M; i++){
        j = dfa[txt.charAt[i]][j];  // no backup
    }
    if(j == M) return i - M;
    else return N;
}

// stream data
public int search(In in){
    int i, j, N = txt.length();
    for(i = 0, j =0; !in.isEmpty()  && j < M; i++){
        j = dfa[in.readChar()][j];  // no backup
    }
    if(j == M) return i - M;
    else return NOT_FOUND;
}


public KMP(String pat){
    this.pat = pat;
    M = pat.length();
    dfa = new int[R][M];
    dfa[pat.charAt(0)][0] = 1;
    for(int X = 0, j =1; j<M; j++){
        for(int c = 0; c < R; c++) dfa[c][j] = dfa[c][x];
        dfa[pat.charAt(j)][j] = j+1;
        X = dfa[pat.charAt(j)][x];
    }
}



----------------------------------------------------------


----------------------------------------------------------




